README
-------

BUILD INSTRUCTIONS
-------------------

* A binary is already available at bin/Release/AcaiBerry, but it case it doesn't work..

* type `qmake && make release && bin/Release/AcaiBerry`

* Tested against Qt 4.5 on Linux, but should build against earlier versions of Qt as well, and I think it would work on Windows too.

* doxygen 'documentation' is available at doxygen/html/index.html. I don't have very much documentation aside from class descriptions, but it might be useful for seeing how things are laid out.

DESCRIPTION OF THE ALGORITHM
-----------------------------

* The AI is pretty simple-minded -- it just generates every possible move for the current turn and chooses the highest possible score.

* To quickly generate permutations of the letters on the rack, I use a directed acyclic graph (DAG) of the wordlist file 'sowpods.txt'. (It's a standard scrabble wordlist.) For example, the words 'CORD', 'CARD', and 'CARP' would be converted into the following graph:

  A -- R -- P
 / \ 
C   R -- D
 \ /
  O

* In the above example, if the computer doesn't have the letter 'C' in its rack, it won't even bother looking at the rest of the graph. This reduces the number of comparisons necessary.

* Now for the placing of tiles on the board. Any tile the program places while making a horizontal move must not inadvertently create an invalid vertical word, and vice versa. For example, consider the following board:

    H E
* * * *
    A
    R
    T

* The row with the asterisk symbols indicates the one the program will be generating moves for. We can see that the first and second asterisk can be filled with any letter. The third can only be filled by one possible letter -- 'E', to form 'HEART'. The last one can be filled by quite a few more characters, but it is still constrained by the 'E' on top.

* Before the computer generates any moves, it first calculates all these 'constraints' imposed by the tiles on the board. Then it traverses the word-graph created earlier with the traversal pruned by these constraints.

* Referring back to the first example: if the computer knows its second character is constrained to be an 'O', then it won't look at the top 'A', 'R', and 'P'.

* All this makes for fairly efficient move generation. I learnt this from the paper by Andrew Appel and Guy Jacobson, and it's supposedly the 'granddaddy algorithm' of modern scrabble AI.

* Actually, their paper also describes a nice system that ensures no move is generated twice. But I think my explanation has been long-winded enough (:

NOTES ON THE IMPLEMENTATION
----------------------------
* My design is probably quite 'weird' -- I let the AI have its own thread, and it is constantly polling the 'game master' on whether it is its turn to move. I did this to simulate what I real human player would do, so that my interface could be more 'generic'. (A human player would just watch the screen.) On hindsight, this probably over-complicated things and wasn't such a great idea.

* The code which I used to generate the DAG from the wordlist has been lost. However, the DAG itself is stored in binary form ('dawg.bin') and so I just load it from there.

* Although I spent most of the time here describing the AI, more than half of the codebase is actually used for the GUI. Heh.
